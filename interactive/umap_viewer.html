<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive UMAP Plot Generator</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for a cleaner look */
        body {
            font-family: 'Inter', sans-serif;
        }
        #loader {
            border-top-color: #4f46e5;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
     <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 min-h-screen flex items-center justify-center p-4">

    <div class="w-full max-w-5xl bg-white dark:bg-gray-800 rounded-2xl shadow-2xl p-6 md:p-8 space-y-6">
        <!-- Header Section -->
        <div class="text-center">
            <h1 class="text-3xl md:text-4xl font-bold text-indigo-600 dark:text-indigo-400">Interactive UMAP Plot Generator</h1>
            <p class="mt-2 text-gray-600 dark:text-gray-400">Visualize your TNF frequency data. Upload your files to begin.</p>
        </div>

        <!-- File Input Section -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div class="flex flex-col space-y-2">
                <label for="data-file" class="font-semibold">1. TNF Frequency Data (.csv)</label>
                <input type="file" id="data-file" accept=".csv" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 dark:file:bg-indigo-900 file:text-indigo-700 dark:file:text-indigo-300 hover:file:bg-indigo-100 dark:hover:file:bg-indigo-800 cursor-pointer"/>
                <small class="text-gray-500 dark:text-gray-400">First column must be the genome/contig identifier.</small>
            </div>
            <div class="flex flex-col space-y-2">
                <label for="metadata-file" class="font-semibold">2. Metadata File (.csv)</label>
                <input type="file" id="metadata-file" accept=".csv" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 dark:file:bg-indigo-900 file:text-indigo-700 dark:file:text-indigo-300 hover:file:bg-indigo-100 dark:hover:file:bg-indigo-800 cursor-pointer"/>
                <small class="text-gray-500 dark:text-gray-400">Must contain genome ID and category columns.</small>
            </div>
        </div>

        <!-- Action Button -->
        <div class="text-center pt-4">
            <button id="generate-plot" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-8 rounded-full shadow-lg transform transition-transform duration-200 hover:scale-105 focus:outline-none focus:ring-4 focus:ring-indigo-300 dark:focus:ring-indigo-800" disabled>
                Loading Libraries...
            </button>
        </div>

        <!-- Status/Error Messages -->
        <div id="status-message" class="text-center text-red-500 font-medium"></div>

        <!-- Plotting Area -->
        <div id="plot-container" class="w-full h-[60vh] min-h-[400px] bg-gray-50 dark:bg-gray-900/50 rounded-lg shadow-inner flex items-center justify-center">
             <div id="loader" class="hidden w-16 h-16 border-8 border-gray-200 dark:border-gray-700 rounded-full animate-spin"></div>
            <div id="plot" class="w-full h-full"></div>
        </div>
    </div>

    <!-- Main application script -->
    <script>
        // --- Library URLs ---
        const SCRIPT_URLS = [
            "https://cdn.plot.ly/plotly-2.32.0.min.js",
            "https://unpkg.com/papaparse@5.3.2/papaparse.min.js", // Switched to unpkg CDN
            "https://unpkg.com/umap-js@1.3.3/lib/umap-js.js"
        ];

        /**
         * Dynamically loads a script and returns a promise that resolves when it's loaded.
         * @param {string} src The URL of the script to load.
         * @returns {Promise<void>}
         */
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = () => resolve();
                script.onerror = () => reject(new Error(`Failed to load script: ${src}`));
                document.head.appendChild(script);
            });
        }

        /**
         * Main function to initialize the application after all libraries are loaded.
         */
        async function initializeApp() {
            // --- DOM Element References ---
            const dataFileInput = document.getElementById('data-file');
            const metadataFileInput = document.getElementById('metadata-file');
            const generateBtn = document.getElementById('generate-plot');
            const plotDiv = document.getElementById('plot');
            const loader = document.getElementById('loader');
            const statusMessage = document.getElementById('status-message');

            // Enable the button and set its text now that libraries are loaded.
            generateBtn.disabled = false;
            generateBtn.textContent = 'Generate UMAP Plot';

            // --- Event Listener ---
            generateBtn.addEventListener('click', handlePlotGeneration);

            /**
             * Handles the entire plot generation process on button click.
             */
            async function handlePlotGeneration() {
                statusMessage.textContent = '';
                loader.classList.remove('hidden');
                Plotly.purge(plotDiv);

                if (!dataFileInput.files[0] || !metadataFileInput.files[0]) {
                    showError("Please select both data and metadata files.");
                    return;
                }

                try {
                    const [data, metadata] = await Promise.all([
                        parseCsv(dataFileInput.files[0]),
                        parseCsv(metadataFileInput.files[0])
                    ]);
                    
                    const { features, labels, contigNames } = processData(data, metadata);
                    const scaledFeatures = standardize(features);

                    statusMessage.textContent = "Running UMAP... this may take a moment.";
                    // Use a timeout to allow the status message to render before the blocking UMAP task
                    await new Promise(resolve => setTimeout(resolve, 10)); 

                    const umap = new UMAP({ nNeighbors: 15, minDist: 0.1, nComponents: 2 });
                    const embedding = umap.fit(scaledFeatures);

                    statusMessage.textContent = "Generating plot...";
                    plotUMAP(embedding, labels, contigNames);

                } catch (error) {
                    showError(error.message);
                    console.error(error);
                } finally {
                    loader.classList.add('hidden');
                    statusMessage.textContent = '';
                }
            }

            /**
             * Parses a CSV file using PapaParse.
             * @param {File} file The file to parse.
             * @returns {Promise<Array<Object>>}
             */
            function parseCsv(file) {
                return new Promise((resolve, reject) => {
                    Papa.parse(file, {
                        header: true,
                        skipEmptyLines: true,
                        complete: (results) => resolve(results.data),
                        error: (err) => reject(new Error(`CSV Parsing Error: ${err.message}`))
                    });
                });
            }

            /**
             * Merges data and metadata, and separates features from labels.
             * @param {Array<Object>} data The main TNF frequency data.
             * @param {Array<Object>} metadata The metadata.
             * @returns {{features: number[][], labels: string[], contigNames: string[]}}
             */
            function processData(data, metadata) {
                if (data.length === 0 || metadata.length === 0) {
                    throw new Error("One or both CSV files are empty or improperly formatted.");
                }

                const dataIdColumn = Object.keys(data[0])[0];
                const metaIdColumn = Object.keys(metadata[0])[0];
                const categoryColumn = Object.keys(metadata[0])[1];

                if (!categoryColumn) {
                    throw new Error("Metadata file must have at least two columns: Identifier and Category.");
                }

                const metadataMap = new Map(metadata.map(row => [row[metaIdColumn], row[categoryColumn]]));
                const features = [], labels = [], contigNames = [];

                data.forEach(row => {
                    const id = row[dataIdColumn];
                    if (metadataMap.has(id)) {
                        labels.push(metadataMap.get(id));
                        contigNames.push(id);
                        
                        const featureRow = Object.values(row).slice(1).map(Number);
                        if (featureRow.some(isNaN)) {
                            throw new Error(`Non-numeric value in data for contig '${id}'. All frequency columns must be numeric.`);
                        }
                        features.push(featureRow);
                    }
                });

                if (features.length === 0) {
                    throw new Error("No matching identifiers found between data and metadata files.");
                }
                
                return { features, labels, contigNames };
            }

            /**
             * Standardizes feature data (z-score normalization).
             * @param {number[][]} data The 2D array of features.
             * @returns {number[][]} The scaled data.
             */
            function standardize(data) {
                const numFeatures = data[0].length;
                const scaledData = Array.from({ length: data.length }, () => []);

                for (let j = 0; j < numFeatures; j++) {
                    const column = data.map(row => row[j]);
                    const mean = column.reduce((a, b) => a + b, 0) / column.length;
                    const stdDev = Math.sqrt(column.map(x => (x - mean) ** 2).reduce((a, b) => a + b, 0) / column.length);

                    for (let i = 0; i < data.length; i++) {
                        scaledData[i][j] = stdDev === 0 ? 0 : (data[i][j] - mean) / stdDev;
                    }
                }
                return scaledData;
            }

            /**
             * Creates an interactive UMAP plot using Plotly.js.
             * @param {number[][]} embedding The 2D UMAP coordinates.
             * @param {string[]} labels The category for each point.
             * @param {string[]} contigNames The identifier for each point (for hover text).
             */
            function plotUMAP(embedding, labels, contigNames) {
                const uniqueLabels = [...new Set(labels)];
                const plotData = uniqueLabels.map(label => {
                    const indices = labels.map((l, i) => l === label ? i : -1).filter(i => i !== -1);
                    return {
                        x: indices.map(i => embedding[i][0]),
                        y: indices.map(i => embedding[i][1]),
                        text: indices.map(i => contigNames[i]),
                        mode: 'markers',
                        type: 'scatter',
                        name: label,
                        hoverinfo: 'text+name',
                        marker: { size: 8, opacity: 0.8 }
                    };
                });

                const layout = {
                    title: '<b>UMAP Projection of TNF Frequencies</b>',
                    xaxis: { title: 'UMAP 1' },
                    yaxis: { title: 'UMAP 2' },
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: 'rgba(0,0,0,0)',
                    font: { color: document.body.classList.contains('dark') ? '#e5e7eb' : '#1f2937' },
                    legend: { title: { text: '<b>Category</b>' } },
                    hovermode: 'closest'
                };
                
                Plotly.newPlot('plot', plotData, layout, { responsive: true });
            }

            /**
             * Displays an error message to the user.
             * @param {string} message The error message to display.
             */
            function showError(message) {
                statusMessage.textContent = message;
                loader.classList.add('hidden');
            }
        }

        // Start the loading process and initialize the app once done.
        Promise.all(SCRIPT_URLS.map(loadScript))
            .then(initializeApp)
            .catch(error => {
                console.error(error);
                const generateBtn = document.getElementById('generate-plot');
                generateBtn.textContent = 'Failed to load libraries';
                document.getElementById('status-message').textContent = 'Error: Could not load required libraries. Please check your internet connection and refresh the page.';
            });
    </script>
</body>
</html>

